package utils

import (
	"net/http"
	"time"
	"unsafe"

	"github.com/gin-gonic/gin"
	jsoniter "github.com/json-iterator/go"
)

// 1. 初始化自定义JSON编码器（兼容旧版jsoniter，无TimeFormat字段）
var jsonEncoder jsoniter.API

func init() {
	// 1.1 创建jsoniter配置（旧版本无TimeFormat，用默认配置）
	config := jsoniter.Config{
		EscapeHTML: false, // 避免HTML转义
	}.Froze()

	// 1.2 注册自定义time.Time序列化器（核心：替代TimeFormat）
	config.RegisterTypeEncoderFunc(
		"time.Time",
		func(ptr unsafe.Pointer, stream *jsoniter.Stream) {
			// 转换为time.Time类型
			t := (*time.Time)(ptr)
			// 自定义日期格式（2006-01-02 15:04:05）
			formatStr := t.Format("2006-01-02 15:04:05")
			// 写入JSON字符串（自动加引号）
			stream.WriteString(formatStr)
		},
		// 判断是否为空（time.Time默认值为零值时触发）
		func(ptr unsafe.Pointer) bool {
			t := (*time.Time)(ptr)
			return t.IsZero()
		},
	)

	// 1.3 注册自定义time.Time反序列化器（可选，前端传参时用）
	config.RegisterTypeDecoderFunc(
		"time.Time",
		func(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
			// 读取JSON字符串
			str := iter.ReadString()
			// 解析为time.Time
			t, err := time.Parse("2006-01-02 15:04:05", str)
			if err != nil {
				iter.ReportError("decode time.Time", err.Error())
				return
			}
			// 赋值给指针
			*(*time.Time)(ptr) = t
		},
	)

	// 1.4 赋值给全局编码器
	jsonEncoder = config
}

// 2. 自定义Gin响应渲染器（实现gin.Render接口）
type CustomJSONRender struct {
	Data interface{}
}

// 实现gin.Render接口的Render方法（Gin 1.10.0 原生支持）
func (c *CustomJSONRender) Render(w http.ResponseWriter) error {
	// 设置JSON响应头
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// 用自定义编码器序列化数据
	bytes, err := jsonEncoder.Marshal(c.Data)
	if err != nil {
		return err
	}
	// 写入响应体
	_, err = w.Write(bytes)
	return err
}

// 3. 封装自定义JSON响应函数（替代gin.Context.JSON）
func JSON(c *gin.Context, code int, data interface{}) {
	c.Status(code)
	if data == nil {
		return
	}
	// 使用自定义渲染器
	c.Render(code, &CustomJSONRender{Data: data})
}
